线程池实现方法
    分为调度线程，与实现处理线程
    调试线程一般只有一个，处理线程根据用户的需要去选择，一般为多个
    调试线程先将要处理任务添加到处理队列中，然后处理线程读到处理队列的任务，再单独处理每个任务，处理完任务后，继续读取处理线程中的任务，直接处理队列中无任务时，处理线程可进入休眠状态

三种设计方法
第一种，只有一个任务处理队列，每次每个处理线程在读取任务时，将任务队列加上锁，读取完后再解锁给下一个线程处理，这样的好处是在遇到长时间需要处理的任务时,可以保证任务可以顺序的执行。坏处就是遇到短任务时，很多的时间会浪费在读到任务锁上。

第二种，是每个线程都有一个处理队列，每个线程只处理自己线程队列中的任务，调试线程将任务根据一定的算法(一般为轮流分配处理，也可以根据线程中队列的个数来分配)来分析任务到每个线程的处理队列中，这样的好处与坏处刚好与第一种的相反，其好处就是处理大量的任务时处理速度会非常快，不需要去加解锁，只需要处理其本线程中的任务队列即可，其坏处则是无法保证任务的顺序执行，且当线程遇到长任务时，其后的任务则不知什么时候才能完成。

第三种，则是每一种与第二种的结合，任务处理队列则有二种，一种为长任务队列，一种为线程内的任务队列，长任务队列则由处理线程公有，而线程内的任务队列只处理短任务，调试线程根据一定的算法()来判断任务的长短，若是长任务，则将其添加的公用的长任务队列中去，若为短任务，则将其根据第二种方法中的算法将其添加到线程中的处理队列中去;处理线程优先处理其自身的任务，当其任务处理完以后，再读取长任务队列中的任务来处理。其好处则是短任务可优先处理完成，再去处理长处务，其坏处就是实现的复杂度大大提升。


gcc mgThreadpool_test.c mgThreadpool.c -o threadpool -g -D_GNU_SOURCE -lmgStd -lpthread
